<!DOCTYPE html>
<!-- saved from url=(0136)#!/#collapse1 -->
<html ng-app="CoursesApp"
  class="js flexbox canvas canvastext webgl no-touch geolocation postmessage no-websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers no-applicationcache svg inlinesvg smil svgclippaths ng-scope fontawesome-i2svg-active fontawesome-i2svg-complete"
  lang="es"><!--<![endif]-->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <style data-merge-styles="true"></style>
  <style data-merge-styles="true"></style>
  <style type="text/css">
    svg:not(:root).svg-inline--fa {
      overflow: visible
    }

    .svg-inline--fa {
      display: inline-block;
      font-size: inherit;
      height: 1em;
      overflow: visible;
      vertical-align: -.125em
    }

    .svg-inline--fa.fa-lg {
      vertical-align: -.225em
    }

    .svg-inline--fa.fa-w-1 {
      width: .0625em
    }

    .svg-inline--fa.fa-w-2 {
      width: .125em
    }

    .svg-inline--fa.fa-w-3 {
      width: .1875em
    }

    .svg-inline--fa.fa-w-4 {
      width: .25em
    }

    .svg-inline--fa.fa-w-5 {
      width: .3125em
    }

    .svg-inline--fa.fa-w-6 {
      width: .375em
    }

    .svg-inline--fa.fa-w-7 {
      width: .4375em
    }

    .svg-inline--fa.fa-w-8 {
      width: .5em
    }

    .svg-inline--fa.fa-w-9 {
      width: .5625em
    }

    .svg-inline--fa.fa-w-10 {
      width: .625em
    }

    .svg-inline--fa.fa-w-11 {
      width: .6875em
    }

    .svg-inline--fa.fa-w-12 {
      width: .75em
    }

    .svg-inline--fa.fa-w-13 {
      width: .8125em
    }

    .svg-inline--fa.fa-w-14 {
      width: .875em
    }

    .svg-inline--fa.fa-w-15 {
      width: .9375em
    }

    .svg-inline--fa.fa-w-16 {
      width: 1em
    }

    .svg-inline--fa.fa-w-17 {
      width: 1.0625em
    }

    .svg-inline--fa.fa-w-18 {
      width: 1.125em
    }

    .svg-inline--fa.fa-w-19 {
      width: 1.1875em
    }

    .svg-inline--fa.fa-w-20 {
      width: 1.25em
    }

    .svg-inline--fa.fa-pull-left {
      margin-right: .3em;
      width: auto
    }

    .svg-inline--fa.fa-pull-right {
      margin-left: .3em;
      width: auto
    }

    .svg-inline--fa.fa-border {
      height: 1.5em
    }

    .svg-inline--fa.fa-li {
      width: 2em
    }

    .svg-inline--fa.fa-fw {
      width: 1.25em
    }

    .fa-layers svg.svg-inline--fa {
      bottom: 0;
      left: 0;
      margin: auto;
      position: absolute;
      right: 0;
      top: 0
    }

    .fa-layers {
      display: inline-block;
      height: 1em;
      position: relative;
      text-align: center;
      vertical-align: -.125em;
      width: 1em
    }

    .fa-layers svg.svg-inline--fa {
      -webkit-transform-origin: center center;
      transform-origin: center center
    }

    .fa-layers-counter,
    .fa-layers-text {
      display: inline-block;
      position: absolute;
      text-align: center
    }

    .fa-layers-text {
      left: 50%;
      top: 50%;
      -webkit-transform: translate(-50%, -50%);
      transform: translate(-50%, -50%);
      -webkit-transform-origin: center center;
      transform-origin: center center
    }

    .fa-layers-counter {
      background-color: #ff253a;
      border-radius: 1em;
      color: #fff;
      height: 1.5em;
      line-height: 1;
      max-width: 5em;
      min-width: 1.5em;
      overflow: hidden;
      padding: .25em;
      right: 0;
      text-overflow: ellipsis;
      top: 0;
      -webkit-transform: scale(.25);
      transform: scale(.25);
      -webkit-transform-origin: top right;
      transform-origin: top right
    }

    .fa-layers-bottom-right {
      bottom: 0;
      right: 0;
      top: auto;
      -webkit-transform: scale(.25);
      transform: scale(.25);
      -webkit-transform-origin: bottom right;
      transform-origin: bottom right
    }

    .fa-layers-bottom-left {
      bottom: 0;
      left: 0;
      right: auto;
      top: auto;
      -webkit-transform: scale(.25);
      transform: scale(.25);
      -webkit-transform-origin: bottom left;
      transform-origin: bottom left
    }

    .fa-layers-top-right {
      right: 0;
      top: 0;
      -webkit-transform: scale(.25);
      transform: scale(.25);
      -webkit-transform-origin: top right;
      transform-origin: top right
    }

    .fa-layers-top-left {
      left: 0;
      right: auto;
      top: 0;
      -webkit-transform: scale(.25);
      transform: scale(.25);
      -webkit-transform-origin: top left;
      transform-origin: top left
    }

    .fa-lg {
      font-size: 1.33333em;
      line-height: .75em;
      vertical-align: -.0667em
    }

    .fa-xs {
      font-size: .75em
    }

    .fa-sm {
      font-size: .875em
    }

    .fa-1x {
      font-size: 1em
    }

    .fa-2x {
      font-size: 2em
    }

    .fa-3x {
      font-size: 3em
    }

    .fa-4x {
      font-size: 4em
    }

    .fa-5x {
      font-size: 5em
    }

    .fa-6x {
      font-size: 6em
    }

    .fa-7x {
      font-size: 7em
    }

    .fa-8x {
      font-size: 8em
    }

    .fa-9x {
      font-size: 9em
    }

    .fa-10x {
      font-size: 10em
    }

    .fa-fw {
      text-align: center;
      width: 1.25em
    }

    .fa-ul {
      list-style-type: none;
      margin-left: 2.5em;
      padding-left: 0
    }

    .fa-ul>li {
      position: relative
    }

    .fa-li {
      left: -2em;
      position: absolute;
      text-align: center;
      width: 2em;
      line-height: inherit
    }

    .fa-border {
      border: solid .08em #eee;
      border-radius: .1em;
      padding: .2em .25em .15em
    }

    .fa-pull-left {
      float: left
    }

    .fa-pull-right {
      float: right
    }

    .fa.fa-pull-left,
    .fab.fa-pull-left,
    .fal.fa-pull-left,
    .far.fa-pull-left,
    .fas.fa-pull-left {
      margin-right: .3em
    }

    .fa.fa-pull-right,
    .fab.fa-pull-right,
    .fal.fa-pull-right,
    .far.fa-pull-right,
    .fas.fa-pull-right {
      margin-left: .3em
    }

    .fa-spin {
      -webkit-animation: fa-spin 2s infinite linear;
      animation: fa-spin 2s infinite linear
    }

    .fa-pulse {
      -webkit-animation: fa-spin 1s infinite steps(8);
      animation: fa-spin 1s infinite steps(8)
    }

    @-webkit-keyframes fa-spin {
      0% {
        -webkit-transform: rotate(0);
        transform: rotate(0)
      }

      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg)
      }
    }

    @keyframes fa-spin {
      0% {
        -webkit-transform: rotate(0);
        transform: rotate(0)
      }

      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg)
      }
    }

    .fa-rotate-90 {
      -webkit-transform: rotate(90deg);
      transform: rotate(90deg)
    }

    .fa-rotate-180 {
      -webkit-transform: rotate(180deg);
      transform: rotate(180deg)
    }

    .fa-rotate-270 {
      -webkit-transform: rotate(270deg);
      transform: rotate(270deg)
    }

    .fa-flip-horizontal {
      -webkit-transform: scale(-1, 1);
      transform: scale(-1, 1)
    }

    .fa-flip-vertical {
      -webkit-transform: scale(1, -1);
      transform: scale(1, -1)
    }

    .fa-flip-horizontal.fa-flip-vertical {
      -webkit-transform: scale(-1, -1);
      transform: scale(-1, -1)
    }

    :root .fa-flip-horizontal,
    :root .fa-flip-vertical,
    :root .fa-rotate-180,
    :root .fa-rotate-270,
    :root .fa-rotate-90 {
      -webkit-filter: none;
      filter: none
    }

    .fa-stack {
      display: inline-block;
      height: 2em;
      position: relative;
      width: 2em
    }

    .fa-stack-1x,
    .fa-stack-2x {
      bottom: 0;
      left: 0;
      margin: auto;
      position: absolute;
      right: 0;
      top: 0
    }

    .svg-inline--fa.fa-stack-1x {
      height: 1em;
      width: 1em
    }

    .svg-inline--fa.fa-stack-2x {
      height: 2em;
      width: 2em
    }

    .fa-inverse {
      color: #fff
    }

    .sr-only {
      border: 0;
      clip: rect(0, 0, 0, 0);
      height: 1px;
      margin: -1px;
      overflow: hidden;
      padding: 0;
      position: absolute;
      width: 1px
    }

    .sr-only-focusable:active,
    .sr-only-focusable:focus {
      clip: auto;
      height: auto;
      margin: 0;
      overflow: visible;
      position: static;
      width: auto
    }
  </style>
  <style type="text/css">
    [ng\:cloak],
    [ng-cloak],
    [data-ng-cloak],
    [x-ng-cloak],
    .ng-cloak,
    .x-ng-cloak,
    .ng-hide:not(.ng-hide-animate) {
      display: none !important;
    }

    ng\:form {
      display: block;
    }

    .ng-animate-shim {
      visibility: hidden;
    }

    .ng-anchor {
      position: absolute;
    }

    h4 {
      margin-top: 50px !important;
    }
  </style>

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Tecnologías de la información</title>
  <meta name="description" content="Plataforma de arranque para los cursos de Formación Docente.">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="shortcut icon" href="../../assets/images/ircfavicon.ico">
  <!-- or, set /favicon.ico for IE10 win -->
  <meta name="msapplication-TileColor" content="#D83434">

  <!-- font -->
  <link href="../../assets/css" rel="stylesheet">

  <!-- bootstrap -->
  <link rel="stylesheet" href="../../assets/bootstrap.min.css">

  <script src="../../assets/jquery.min.js.descarga"></script>

  <!--scripts -->
  <!--bootstrap -->
  <script src="../../assets/bootstrap.min.js.descarga"></script>


  <link rel="stylesheet" href="../../assets/normalize.css">
  <link rel="stylesheet" href="../../assets/milligram.min.css">
  <link rel="stylesheet" href="../../assets/styles.css">
  <script src="../../assets/modernizr-2.7.1.min.js.descarga"></script>


  <link rel="stylesheet" href="../../highlight/vs.css">
  <link rel="stylesheet" href="../../highlight/default.min.css">
</head>

<body>

  <header>
    <div class="menu-accesibilidad">
    </div>
    <div>
      Sistemas Inteligentes
    </div>
  </header>

  <nav>
    <div class="container menu-principal">
      <div class="row">
        <div class="column">
          <ul class="menu">

            <li class="unidad-activa"><a href="#unidad-1" title="unidad 1">U2</a></li>

          </ul>
        </div>
        <div class="column">

        </div>
      </div>
    </div>
    <div id="submenu">
      <div class="container">
        <div class="row">
          <div class="column">
            <ul id="unidad-1" style="display: none;">

          </div>
        </div>
      </div>
    </div>
  </nav>


  <div id="pagina-1"></div>
  <section class="wrapper">
    <div class="contenido-principal">
      <article>
        <h1><span>Unidad 2: </span>Búsqueda</h1>

        <h2><img class="icono-link" src="../../assets/images/presentacion_unidad.svg" width="15%"> Presentación de
          unidad</h2>
      </article>


      <article class="row">
        <div class="column" id="yui_3_18_1_1_1748021549449_94">
          <p id="yui_3_18_1_1_1748021549449_93">En
            esta unidad el estudiante podrá vincular la práctica y la teoría relacionada
            con los <a class="autolink" title="Sistemas de Búsqueda"
              href="https://urc.cdmx.gob.mx/LAD_A1_2025-1/mod/book/view.php?id=5664">sistemas de búsqueda</a> en una
            inteligencia artificial.</p>

          <p>Debido
            a que la búsqueda es el núcleo de muchos procesos inteligentes, es adecuado
            estructurar los programas de IA de forma que se facilite describir y
            desarrollar el proceso de búsqueda. Los sistemas de producción proporcionan
            tales estructuras. </p>

          <p><b>Un
              sistema de producción consiste en:</b>
          </p>

          <ul>
            <li>
              Un conjunto de reglas.
            </li>

            <li>
              Una o más bases de
              datos/conocimiento.
            </li>

            <li>
              Una estrategia de control que
              especifique el orden en el que las reglas se comparan con la base de datos, y
              la forma de resolver los conflictos que surjan cuando varias reglas puedan ser
              aplicadas a la vez.
            </li>

            <li>
              Un aplicador de reglas.
            </li>
          </ul>


          <p>El
            proceso de solución del problema puede modelarse como un sistema de producción.
            El problema que se plantea es escoger la estructura de control apropiada para
            el sistema de producción (base de datos, hechos, conocimiento o información
            sobre el problema, conjunto de reglas o aplicadro) con el fin de que el proceso
            de búsqueda sea lo más eficiente posible.</p>

          <p><b>Existen
              varias taxonomías de los sistemas de producción / búsqueda / estrategia de
              control (J. Molina, C. Torres, 2008):</b></p>

          <ul>
            <li>Informada
              / no informada</li>

            <li>
              Irrevocable
              / tentativa
            </li>

            <li>
              Hacia adelante / hacia atrás / bidireccional
            </li>
          </ul>


      </article>

      <article class="row objetivo">
        <div class="column">
          <h2><img class="icono-link" src="../../assets/images/objetivo.svg" width="18%"> Objetivo de unidad</h2>

          <p>Al finalizar la unidad, el alumno podrá vincular la práctica y la teoría relacionada con los sistemas de
            búsqueda en una
            inteligencia artificial.</p>
        </div>
      </article>
      <p class="bienvenida">¡Bienvenidos a esta unidad!</p>

    </div>
  </section>

  <div id="pagina-2"></div>
  <section class="wrapper">
    <div class="contenido-principal">
      <article>
        <h2>Sistemas de Búsqueda</h2>
      </article>

      <article class="title-spacing">
        <h3>1. Búsqueda</h3>
      </article>

      <article class="row">
        <div class="column" id="yui_3_18_1_1_1748021903788_96">
          <p id="yui_3_18_1_1_1748021903788_95">La
            búsqueda en inteligencia pretende resolver los problemas o tareas complejas a
            través de algoritmos que garanticen la solución del problema o tarea. Los
            sistemas o las técnicas de búsqueda son una serie de esquemas de representación
            del conocimiento, que mediante diversos algoritmos nos permite resolver
            problemas desde el punto de vista de lA.
          </p>

          <p style="text-align: center;"><img src="./ia.jpg"
              alt="INTELIGENCIA ARTIFICIAL: Técnicas de Búsqueda en la Inteligencia artificial">
          </p>

          <p>A
            continuación se profundiza en las diferentes técnicas de búsqueda:</p>

          <b>a)</b> Aplicar el operador a m, obtener un nuevo estado y crear un puntero que
          permita saber que su predecesor esm.
          </p>

          <p>

            2.2 Si la profundidad de m es igual a lp regresar a 2.1. En caso contrario
            continuar. 2.3 Expandir m (generar todos los sucesores). Para cada operador
            aplicable y cada forma de aplicación: <br>&nbsp;<br>1.&nbsp;&nbsp;&nbsp; Crear una lista de nodos
            llamada ABIERTA e “inicializarla”<br>con un<br>único nodo raíz, al que se le asigna el estado inicial
            del<br>problema.<br>2.&nbsp;&nbsp;&nbsp; Hasta que ABIERTA esté vacía o se encuentre una meta o
            se<br>devuelva fallo realizar las siguientes acciones:<br>2.1 Si ABIERTA está vacía terminar con fallo: en
            caso<br>contrario continuar.<br>2.2 Extraer el primer nodo de ABIERTA y llamar a ese nodo m.<br>2.3 Si la
            profundidad de m es igual a lp o si m no tiene más<br>sucesores posibles (que no hayan sido examinados
            anteriormente) eliminarlo de<br>ABIERTA y regresar a regresar a 2. En caso contrario continuar.<br>2.4
            Generar un
            “nuevo” sucesor m ́ de m. e introducirlo al<br>principio de ABIERTA. , creando un puntero a m, y señalar
            que dicha
            rama ya ha<br>sido considerada.<br>2.4.1 Si m ́ es meta, abandonar el proceso iterativo iniciado<br>en el
            paso 2
            devolviendo el camino de la solución, que se obtiene recorriendo<br>los punteros de sus
            antepasados.<br>2.4.2 Si m
            ́se encuentra en un callejón sin salida<br>eliminarlo de ABIERTA. Se continúa el proceso iterativo en el
            paso 2.
          </p>


          <h4>Búsqueda sin información del dominio </h4>

          <p style="">También
            se denominan técnicas de búsqueda ciega, porque realizan una búsqueda
            sistemática y objetiva (en el sentido de que el control del proceso no depende
            del problema concreto que se esté resolviendo).</p>

          <p style="">Por el
            contrario las técnicas de búsqueda heurística realizan una búsqueda
            informada e intentan optimizar dicho proceso eligiendo los caminos que a priori
            van a suponer un menor coste.</p>


          <h4>Objetivos</h4>

          <ul>
            <li>
              Encontrar el camino óptimo
              entre la descripción del problema o estado inicial y el estado meta.
            </li>

            <li>
              A veces basta con devolver el
              estado meta y no es necesario conocer todo el camino.
            </li>
          </ul>



          <h4>Características:</h4>

          <ul>
            <li>
              No dejar (a priori) ningún
              nodo sin explorar.
            </li>

            <li>
              No explorar un nodo más de una
              vez.
            </li>
          </ul>



          <h4>Búsqueda en amplitud</h4>

          <p>Es aquella estrategia de
            control en la que se revisan todas las
            trayectorias de una determinada longitud antes de crear una trayectoria más
            larga. Es decir, no se genera ningún nodo de nivel N hasta que no se hayan
            obtenido todos los del nivel N-1.</p>


          <h4>Algoritmo de búsqueda en amplitud </h4>

          <p>1.Crear una lista de nodos llamada ABIERTA e
            “inicializarla” con un único nodo raíz, al que se le asigna el estado inicial
            del problema.
          </p>

          <p>2.&nbsp;&nbsp;&nbsp;
            Hasta que ABIERTA esté vacía o se encuentre
            una meta realizar las siguientes acciones:
          </p>

          <p>2.1&nbsp; Extraer
            el primer nodo de ABIERTA y llamar a ese nodo m.</p>

          <p>2.2&nbsp; Expandir
            m (generar todos los sucesores). Para cada operador aplicable y cada forma de
            aplicación:<br></p>

          <p>b) Si
            el nuevo estado generado es meta, salir del proceso iterativo iniciado en 2.2 y
            devolver dicho estado. </p>

          <p>c)&nbsp;&nbsp;&nbsp;
            Incluir el nuevo estado al final de ABIERTA
            (una vez completado este proceso para todos los sucesores de m - cuando no se
            haya encontrado una meta- se continúa el proceso iterativo en el paso 2).
          </p>

          <ul>
            <li>
              En este algoritmo la lista ABIERTA va a
              funcionar como una cola FIFO.
            </li>

            <li>
              Los nodos que haya en ABIERTA serán aquellos
              que hayan sido generados, pero que todavía no han sido expandidos.
            </li>

            <li>
              Los elementos que van a ser expandidos se toman
              al comienzo de la lista ABIERTA.
            </li>

            <li>
              Sus sucesores se añaden al final.
            </li>

            <li>
              De esta forma siempre se expandirán los nodos
              más antiguos.
            </li>
          </ul>



          <p><strong>Ventajas:</strong> si el problema tiene
            una solución este procedimiento garantiza el encontrarla. Si hubiera varias
            soluciones se obtiene la de menor coste (la óptima), es decir, la que requiere
            un menor número de pasos (si consideramos un coste uniforme de aplicación de
            los operadores) </p>

          <p><strong>Desventajas:</strong> si el nivel de
            profundidad asociado a la solución es significativamente menor que el factor
            de ramificación se expandirían demasiados nodos inútilmente. Por otro lado
            la principal desventaja de este método es el espacio de almacenamiento
            requerido. Esto lo hace prácticamente inviable para problemas complejos, como
            suelen ser los del mundo real. </p>

          <h4>Búsqueda en profundidad </h4>

          <p>Es aquél procedimiento de
            control en el que se centra en expandir un único camino desde la raíz. En el
            caso de llegar a un callejón sin salida se retrocede hasta el nodo más
            cercano desde donde se puede tomar una ruta alternativa para poder seguir
            avanzando. </p>

          <p>Para llevar a cabo este tipo
            de búsqueda debe utilizarse una estructura de tipo pila (LIFO) que vaya
            almacenando los nodos generados. Suele establecerse el llamado límite de exploración,
            que marca la máxima longitud que puede alcanzar cualquier camino desde la
            raíz durante el proceso de búsqueda (J. Molina, C. Torres, 2008):</p>


          <h4>Algoritmo de búsqueda en profundidad</h4>


          <p>1.&nbsp;&nbsp;&nbsp;
            Crear una lista de nodos llamada ABIERTA e
            “inicializarla” con un único nodo raíz, al que se le asigna el estado inicial
            del problema.
          </p>

          <p>2.&nbsp;&nbsp;&nbsp;
            Hasta que ABIERTA esté vacía o se encuentre
            una meta realizar las siguientes acciones:
          </p>

          <p>2.1
            Extraer el primer nodo de ABIERTA y llamar a ese nodo m.<br></p>

          <p>1)
            Aplicar el operador a m, obtener un nuevo estado y crear un puntero que permita
            saber que su predecesor es m. </p>

          <p>2) Si
            el nuevo estado generado es meta, salir del proceso iterativo iniciado en 2.1 y
            devolver dicho estado. </p>

          <p>3)
            Incluir el nuevo estado al principio de ABIERTA en un orden arbitrario. </p>


          <ul>
            <li>
              Si algún sucesor de m es meta, abandonar el
              proceso iterativo señalado en 2.1 devolviendo el camino de la solución que se
              obtiene recorriendo los punteros de sus antepasados.
            </li>

            <li>
              Si algún sucesor de m se encuentra en un
              callejón sin salida eliminarlo de ABIERTA y continuar en 2.2
            </li>
          </ul>

          <p><strong>Ventajas:</strong> la principal ventaja
            de esta algoritmo radica en el reducido valor de su complejidad espacial.
            Cuando existen múltiples soluciones posibles la eficiencia del algoritmo
            aumenta. </p>

          <p><strong>Desventajas:</strong> la dificultad
            estriba en el tiempo requerido. El algoritmo puede dedicarse a recorrer un
            camino demasiado largo que no conduzca a ninguna solución. Es más, si no se
            guarda constancia de los nodos que forman el camino recorrido se podría caer
            en ciclos y el proceso no acabaría. </p>

          <p>El problema por tanto es
            determinar cuál debe ser lp. Si éste es inferior a la longitud real del
            camino de la solución, ésta nunca se encontraría, y si es mucho mayor sería
            ineficiente. Esta es la razón por la que lp debería llamarse límite de
            exploración. </p>



          <h4>Búsqueda con retroceso </h4>
          <p>Es una técnica que a
            diferencia de los algoritmos en amplitud y en profundidad (que consideran todos
            los sucesores) solamente expande un sucesor en cada iteración, restringiendo
            por lo tanto el espacio de estados considerado. </p>

          <p>Cuanto mejor sea el criterio
            para limitar el número de estados considerados más eficiente será el proceso
            de búsqueda. </p>

          <p>Es decir, es como el recorrido
            en profundidad pero nos ahorramos tener que expandir todos los nodos para
            obtener sus sucesores. El camino sigue avanzando por ese sucesor, y si nos
            encontramos con un callejón sin salido retrocedemos hasta el primer antepasado
            desde el que todavía partan caminos inexplorados. </p>


          <h4>Algoritmo de búsqueda con retroceso</h4>


          <p><strong>Ventajas:</strong> la
            principal ventaja de esta algoritmo respecto al de profundidad es la de
            necesitar un menor espacio de almacenamiento. Sólo hay que recordar en cada
            instante un sucesor del nodo seleccionado. Otra ventaja es que no se generan
            las ramas del árbol que se encuentran después (a la derecha) de la solución.
          </p>

          <p><strong>Desventajas:</strong>
            Vuelve a ser el problema determinar cuál debe ser lp. Para conocer su valor
            deberíamos saber de antemano en qué nivel se encuentra la solución(J.
            Molina, C. Torres, 2008)<em>:.</em></p>

        </div>
      </article>

      <article class="row">
        <div class="column">
          <div class="panel panel-info">
            <div class="panel-body">
              <div class="tab-content">
                <h3>2. Referencias</h3>
                <div role="tabpanel" class="tab-pane active">
                  <ul>
                    <li>Benítez, A. (2007). Fundamentos de Inteligencia Artificial libro tercero. España: Escolar y
                      mayo.</li>
                    <li>Escolano, F. (2003). Inteligencia Artificial (Modelos, Técnicas y Áreas de Aplicación) México:
                      Thomson.</li>
                    <li>Marín, R. (2008). Inteligencia Artificial y sistemas inteligentes. España: McGraw-Hill.</li>
                    <li>Nilsson, N. (2001). Inteligencia artificial (Una nueva síntesis) México: McGraw–Hill.</li>
                    <li>Ponce, P. (2011). Inteligencia Artificial con aplicaciones a la ingeniería. España: MARCOMBO.
                    </li>
                    <li>SEDU. (2018). Todo sobre inteligencia artificial. Ciudad de México.</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>
    </div>
  </section>

  <div id="pagina-3"></div>
  <section class="wrapper">
    <div class="contenido-principal">
      <article>
        <h2>Búsqueda Heuristica</h2>
      </article>

      <article class="title-spacing">
        <h3>1. La Búsqueda Heurística y sus propiedades</h3>
      </article>

      <article class="row">
        <div class="no-overflow column">
          <p>Las técnicas de búsqueda heurística disponen de
            alguna información sobre la proximidad de cada estado a un estado objetivo, lo
            que permite explorar en primer lugar los caminos más prometedores. </p>

          <p>Las características de las técnicas &nbsp;heurísticas: </p>

          <ul>
            <li>
              No garantizan que se encuentre una solución,
              aunque existan soluciones.
            </li>

            <li>
              Si encuentran una solución, no se asegura que
              ésta tenga las mejoresas propiedades (que sea de longitud mínima o de coste
              óptimo).
            </li>

            <li>
              En algunas ocasiones (que, en general, no se
              podrán determinar a priori), encontrarán una solución (aceptablemente buena)
              en un tiempo razonable.
            </li>
          </ul>


          <p>En general, las técnicas heurísticas son
            preferibles a los métodos no informados en la solución de problemas
            difíciles para los que una búsqueda exhaustiva necesitaría un tiempo
            demasiado grande. Esto cubre prácticamente la totalidad de los problemas
            reales que interesan en Inteligencia Artificial. </p>

          <p>La información del problema concreto que estamos
            intentando resolver se suele expresar por medio de heurísticas. </p>

          <p>El concepto de heurística es difícil de aprender.
            Newell, Shaw y Simon en 1963 dieron la siguiente definición: "Un proceso
            que puede resolver un problema dado, pero que no ofrece ninguna garantía de
            que lo hará, se llama una heurística para ese problema". </p>

          <p>Si nos planteamos seguir concretando como
            aprovechar la información sobre el problema en sistemas de producción, la siguiente
            idea consiste en concentrar toda la información heurística en una única
            función que se denomina función de evaluación heurística. Se trata de una
            función que asocia a cada estado del espacio de estados una cierta cantidad
            numérica que evalúa de algún modo lo prometedor que es ese estado para
            acceder a un estado objetivo. Habitualmente, se denota esa función por h(e).</p>

          <p>La función heurística puede tener dos
            interpretaciones. Por una parte, la función puede ser una estimación de lo próximo
            que se encuentra el estado de un estado objetivo. Bajo esta perspectiva, los
            estados de menor valor heurístico son los preferidos. Pero en otros casos
            puede suceder que lo que convenga sea maximizar esa función.</p>
        </div>
      </article>


      <article class="title-spacing">
        <h3>2. Ejemplos de funciones heurísticas</h3>
      </article>

      <article class="row">
        <div class="column">
          <p>Veamos ejemplos de heurísticas para algunos
            problemas concretos. Para <b>el problema del 8-puzzle</b> tenemos la siguientes
            heurísticas: </p>

          <p><!--[if !supportLists]--><strong>a)</strong>&nbsp;&nbsp;
            <!--[endif]-->La basada en la distancia Manhattan (o distancia
            taxi). Se asocia a cada casilla un número que es la suma de las distancias
            horizontal y vertical a su posición en el tablero objetivo (esto es, la suma
            de diferencias de sus coordenadas x e y). La función heurística es la suma de
            las distancias de cada una de las casillas (excluyendo la que se encuentra
            vacía).
          </p>

          <div style="width: 100%; margin-bottom: 50px;">
            <table border="1" cellspacing="0" cellpadding="0" width="72"
              style="margin: 0 auto; width: 150px; height: 150px;">
              <tbody>
                <tr>
                  <td width="12" style="height: 12px; padding: 0; text-align: center;" valign="top">
                  </td>
                  <td width="12" style="height: 12px; padding: 0; text-align: center;" valign="top">
                    <p style="padding-top: 12px; margin-bottom: -12px;">2</p>
                  </td>
                  <td width="12" style="height: 12px; padding: 0; text-align: center;" valign="top">
                    <p style="padding-top: 12px; margin-bottom: -12px;">3</p>
                  </td>
                </tr>
                <tr>
                  <td width="12" style="height: 12px; padding: 0; text-align: center;" valign="top">
                    <p style="padding-top: 12px; margin-bottom: -12px;">1</p>
                  </td>
                  <td width="12" style="height: 12px; padding: 0; text-align: center;" valign="top">
                    <p style="padding-top: 12px; margin-bottom: -12px;">8</p>
                  </td>
                  <td width="12" style="height: 12px; padding: 0; text-align: center;" valign="top">
                    <p style="padding-top: 12px; margin-bottom: -12px;">4</p>
                  </td>
                </tr>
                <tr>
                  <td width="12" style="height: 12px; padding: 0; text-align: center;" valign="top">
                    <p style="padding-top: 12px; margin-bottom: -12px;">7</p>
                  </td>
                  <td width="12" style="height: 12px; padding: 0; text-align: center;" valign="top">
                    <p style="padding-top: 12px; margin-bottom: -12px;">6</p>
                  </td>
                  <td width="12" style="height: 12px; padding: 0; text-align: center;" valign="top">
                    <p style="padding-top: 12px; margin-bottom: -12px;">5</p>
                  </td>
                </tr>
              </tbody>
            </table>

          </div>

          <p><code>H=n(E<sub>i</sub>)=
          2 (1 de la casilla 1 más 1 de la casilla 8)</code></p>

          <p><!--[if !supportLists]--><strong>b)</strong>&nbsp;&nbsp;
            <!--[endif]-->Otra heurística, mucho más simple, consiste en
            contar el número de casillas que están fuera de su sitio (respecto al tablero
            objetivo). Es una heurística más pobre que la anterior, puesto que no usa la
            información relativa al esfuerzo (número de movimientos) necesario para
            llevar una pieza a su lugar.
          </p>

          <p><strong>Ejercicio:</strong></p>

          <p>Otra heurística posible para el 8-puzzle, si el
            estado objetivo es el recogido en la <i>figura 1</i>, es la siguiente: <code>h(e) = 3 *
            seq(e)</code>, donde <code>seq(e)</code> cuenta 1 si hay un dígito central en <code>e</code> y 2 por cada
            dígito <code>x</code> no central que no es seguido (en el sentido de la agujas del reloj)
            por su sucesor <code>x+1</code> (imponemos por convenio que <code>8 + 1 = 1</code>). </p>
          <ul>
            <li>
              Calcular el valor de esta heurística para los
              estados que aparecen en la tabla anterior.
            </li>
          </ul>
        </div>
      </article>

      <article class="title-spacing">
        <h3>3. El problema del agente viajero</h3>
      </article>

      <article class="row">
        <div class="column">

          <ul>
            <li>
              <strong>Estado inicial:</strong> un viajante se encuentra en una
              capital de provincia.
            </li>

            <li>
              <strong>Estado meta:</strong> quiere viajar a otra capital por la
              mejor ruta posible (la más corta).
            </li>

            <li>
              <strong>Medios:</strong> Las capitales de provincia colindantes
              están unidas por carreteras; se dispone de un mapa con la disposición de las
              provincias y sus "coordenadas" en kilómetros respecto al
              "centro" (por ejemplo, Madrid, con coordenadas (0,0)).
            </li>

            <li>
              Una función heurística para ese problema consiste
              en asignar a cada estado un valor que es la distancia aérea (en línea recta)
              con el estado objetivo. Dicha distancia es la distancia euclídea entre las
              coordenadas de dos ciudades.
            </li>

            <li>
              Se elige una ciudad como siguiente en el camino
              cuando la suma de la distancia a la ciudad actual más la distancia aérea a la
              meta sea la menor.
              </p>
            </li>

            <li>
              Una persona quiere viajar de Madrid a Santander
              considerando el siguiente mapa de carreteras (J.Ramírez, L. Laureano-Cruces,
              2015).
            </li>

          </ul>

          <figure style="text-align: center;">
            <img src="./map1.png" alt="" style="font-size: 0.9375rem;">

            <figcaption>Ilustración 1 Mapa del Problema del Viajero</figcaption>
          </figure>
        </div>
      </article>

      <article class="row">
        <div class="column">
          <div class="panel panel-info">
            <div class="panel-body">
              <div class="tab-content">
                <h3>4. Referencias</h3>
                <div role="tabpanel" class="tab-pane active">
                  <ul>
                    <li>&nbsp;Benítez, A. (2007). <i>Fundamentos de Inteligencia Artificial libro tercero</i>. España:
                      Escolar y mayo.
                    </li>

                    <li>Escolano, F. (2003). <i>Inteligencia Artificial (Modelos, Técnicas y Áreas de Aplicación)</i>
                      México: Thomson.
                    </li>

                    <li>Marín, R. (2008). <i>Inteligencia Artificial y sistemas inteligentes</i>. España: McGraw-Hill.
                    </li>

                    <li>Nilsson, N. (2001).&nbsp; <i>Inteligencia artificial (Una nueva síntesis)</i> México:
                      McGraw–Hill.</li>

                    <li>Ponce, P. (2011). <i>Inteligencia Artificial con aplicaciones a la ingeniería.</i> España:
                      MARCOMBO.</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>
    </div>
  </section>

  <div id="pagina-4"></div>
  <section class="wrapper">
    <div class="contenido-principal">
      <article>
        <h2>Algoritmos Genéticos</h3>
      </article>

      <article class="title-spacing">
        <h3>1. Algoritmos Genéticos</h3>
      </article>

      <article class="row">
        <div class="no-overflow column">
          <p>Los
            algoritmos genéticos pertenecen a la computación evolutiva, son considerados
            también una técnica de inteligencia artificial. A través de millones de años,
            los organismos han evolucionado biológicamente para sobrevivir y crecer en un
            mundo cambiante.
          </p>

          <p>Los
            materiales genéticos de todos los organismos vivos consisten de cromosomas que
            están divididos en genes; su codificación y desarrollo son considerados un
            proceso clave en la continuación de las especies. El proceso de selección
            natural y el sobrevivir de los más aptos son considerados elementos importantes
            en la evolución, que ha sido estudiada desde el siglo XVII. Los Algoritmos
            Genéticos están basados en estos aspectos de evolución.
          </p>

          <p>Los
            algoritmos genéticos utilizan ideas de biología como población de cromosomas,
            selección natural para selección de pareja, cruza para producción de
            descendencia y mutación para diversidad. El punto importante de los algoritmos
            genéticos es la representación de un problema-solución que use un cromosoma de
            longitud constante o cambiante. La variable representada por la posición es un
            gen, y su valor se conoce como alelo. Una vez que obtenida la representación
            (codificado), es decir la manera en que el espacio de soluciones potenciales se
            transforma en el dominio de trabajo, la metodología de Algoritmos Genéticos
            puede ser aplicada para alcanzar una buena solución del problema. El codificado
            más popular por su simplicidad es el binario, donde los alelos son los valores
            de 0 ó 1. De ser necesario, el codificado basado en valor o de caracteres puede
            ser usado también. A pesar de que el codificado fijo es popular, los
            investigadores han usado uno que puede adaptarse para algunos problemas para
            mejorar los resultados.
          </p>

          <p>El uso
            de los Algoritmos genéticos está relacionado con el concepto de Optimización,
            por lo que también es abordada, siendo el objetivo, maximizar el beneficio o
            minimizar el costo. Adicionalmente se muestran algunas aplicaciones de los algoritmos
            genéticos: escoger el arreglo de trabajos y de máquinas para minimizar el
            tiempo de producción, el problema del agente viajero, minimizar la cantidad de
            merma en el corte de madera, vidrio, entre otros; todos ellos problemas
            combinatorios que pueden modelarse a través de programación matemática pero que
            conforme crecen el número de variables no son factibles de resolverse en un
            tiempo computacional razonable; por lo que resulta interesante uso de los algoritmos
            genéticos.
          </p>

          <p>Para
            poder explicar la estructura de los algoritmos genéticos voy a introducir
            primero algunos términos que serán útiles:
          </p>

          <p><strong><u>Individuo</u></strong>:&nbsp;
            los individuos de nuestra población son las posibles soluciones al problema que
            estamos tratando.
          </p>

          <p><strong><u>Población</u></strong>:
            conjunto de individuos (soluciones).
          </p>

          <p><strong><u>Función
                fitness o de adaptación</u></strong>: función que evalúa a los individuos y les
            asigna una puntuación en función de lo buenas soluciones que sean para el
            problema.
          </p>

          <p><strong><u>Función
                de cruce</u></strong>: función que, dados dos individuos, genera
            dos ‘<em>descendientes’</em>&nbsp;a partir de la combinación de genes de
            sus ‘<em>padres’</em>. Esta función se diseña especialmente para
            el problema que se esté tratando y, por lo general, se encarga de que los hijos
            sean mejores soluciones que los padres.
          </p>

          <p>Entonces,
            la estructura de un algoritmo genético es la siguiente:
          </p>

          <ol>
            <li>Se
              genera una población inicial de individuos (soluciones), usualmente de manera
              aleatoria.</li>
            <li><strong>Fase de
                evaluación</strong>: se evalúan los individuos de la población
              con la función fitness.</li>
            <li><strong>Fase de
                selección</strong>: se seleccionan los mejores individuos.</li>
            <li><strong>Fase de
                reproducción</strong>: se cruzan los individuos seleccionados
              mediante la función de cruce, dando lugar a una nueva generación que va a
              sustituir a la anterior.&nbsp;</li>
            <li><strong>Fase de
                mutación</strong>: se introducen mutaciones (pequeños cambios) en ciertos
              individuos de la nueva población de manera aleatoria.</li>
            <li><strong>Tenemos
                una nueva generación, generalmente, con soluciones mejores que la anterior.
                Volvemos al punto 2.</strong></li>
          </ol>

          <p>Los
            algoritmos genéticos finalizan o bien cuando alcanzan un número de generaciones
            concreto o cuando cumplen una condición de parada (M, Gestal, 2013).</p>

          <p>A continuación, para ejemplificar, diagrama de flujo de un algoritmo genético.</p>

          <figure style="text-align: center;">
            <img src="./diagran1.png" alt="Ilustración 2 Diagrama de flujo de un algoritmo genético">
            <figcaption>Ilustración 2 Diagrama de flujo de un algoritmo genético</figcaption>
          </figure>
        </div>
      </article>


      <article class="title-spacing">
        <h3>2. Cierre de unidad</h3>
      </article>

      <article class="row">
        <div class="no-overflow column">
          <p>El hombre es el sistema del que mejor se
            conoce el cómo lleva a cabo las tareas con las que estamos familiarizados y por
            lo tanto tiene sentido fijarse en él para buscar pistas de cómo&nbsp; crear inteligencia artificial. Si lo
            que se
            quiere es escribir programas que simulen el comportamiento humano ante una
            tarea, la forma de medir el éxito está en que el comportamiento del programa
            corresponda con el humano, así como mediante distintas clases de experimentos y
            análisis de protocolos. Cuando se quiere diseñar un programa de IA, se debe
            intentar especificar tan bien como sea posible el criterio de éxito para el
            funcionamiento del programa en su particular y restringido dominio.</p>

          <p>Para construir un sistema que resuelva
            un problema específico, es necesario realizar estas cuatro acciones: </p>

          <ul>
            <li>
              Definir
              el problema con precisión.
            </li>

            <li>
              La
              definición debe incluir especificaciones precisas tanto sobre las situaciones
              iniciales como sobre las situaciones finales que se aceptarían como soluciones
              al problema
            </li>

            <li>
              Analizar
              el problema. Algunas características de gran importancia pueden tener un gran
              efecto sobre la conveniencia o no de utilizar diversas técnicas que resuelvan
              el problema.
            </li>

            <li>
              Aislar
              y representar el conocimiento necesario para resolver el problema.
            </li>

            <li>
              Elegir
              la mejor <b>técnica de búsqueda</b> que resuelva el problema y aplicarla al
              problema particular.
            </li>

          </ul>
        </div>
      </article>

      <article class="row">
        <div class="column">
          <div class="panel panel-info">
            <div class="panel-body">
              <div class="tab-content">
                <h3>3. Referencias</h3>
                <div role="tabpanel" class="tab-pane active">
                  <ul>
                    <li>
                      <span lang="ES">Benitez, R., Escudero, G., Kannan, S. y
                        Masip, R. (2010) Inteligencia Artificial Avanzada. España: UOC.</span>
                    </li>

                    <li>
                      <span lang="ES">Pajares G. y Santos M.
                        (2006). Inteligencia Artificial e Ingeniería del Conocimiento </span></ </li>

                    <li>
                      Alfaomega. ISBN:
                      970-15-1166-2. Mexico. Rusell &amp; Norving (2003). Inteligencia Artificial. Un
                      enfoque moderno, Segunda Edición. Prentice Hall.
                    </li>

                    <li>
                      García Serrano, A.
                      (2016) Inteligencia Artificial. Fundamentos, práctica y aplicaciones. México:
                      Alfaomega.
                    </li>

                    <li>
                      Ponce Cruz, P. (2014)
                      Inteligencia Artificial con aplicaciones en la Ingeniería. México: Alfaomega.
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>
    </div>
  </section>

  <div id="pagina-5"></div>
  <section class="wrapper">
    <div class="contenido-principal">
      <article>
        <h2>Algoritmos Genéticos 2</h3>
      </article>

      <article class="title-spacing">
        <h3>1. Algoritmo Genético</h3>
      </article>

      <article class="row">
        <div class="no-overflow column">
          <p class="Normal1">Los <a class="autolink" title="Algoritmos Genéticos"
              href="https://urc.cdmx.gob.mx/LAD_A1_2025-1/mod/book/view.php?id=5666">Algoritmos Genéticos</a> (AGs) son
            métodos
            adaptativos que pueden usarse para resolver problemas de búsqueda y optimización. Están basados en el
            proceso
            genético de los organismos vivos. A lo largo de las generaciones, las poblaciones evolucionan en la
            naturaleza de
            acorde con los principios de la selección natural y la supervivencia de los más fuertes, postulados por
            Darwin. Por
            imitación de este proceso, los <a class="autolink" title="Algoritmos Genéticos"
              href="https://urc.cdmx.gob.mx/LAD_A1_2025-1/mod/book/view.php?id=5666">Algoritmos Genéticos</a> son
            capaces de ir
            creando soluciones para problemas del mundo real. La evolución de dichas soluciones hacia valores óptimos
            del
            problema depende en buena medida de una adecuada codificación de las mismas.
          </p>

          <p class="Normal1">Un algoritmo genético consiste en una función matemática o una rutina de software que toma
            como
            entradas a los ejemplares y retorna como salidas cuáles de ellos deben generar descendencia para la nueva
            generación.
          </p>

          <p class="Normal1">Versiones más complejas de <a class="autolink" title="Algoritmos Genéticos"
              href="https://urc.cdmx.gob.mx/LAD_A1_2025-1/mod/book/view.php?id=5666">algoritmos genéticos</a> generan un
            ciclo
            iterativo que directamente toma a la especie (el total de los ejemplares) y crea una nueva generación que
            reemplaza
            a la antigua una cantidad de veces determinada por su propio diseño. Una de sus características principales
            es la de
            ir perfeccionando su propia heurística en el proceso de ejecución, por lo que no requiere largos períodos de
            entrenamiento especializado por parte del ser humano, principal defecto de otros métodos para solucionar
            problemas,
            como los Sistemas Expertos.
          </p>

          <ul>
            <li>
              Operan de forma simultánea con varias soluciones, en vez de trabajar de forma secuencial
              como las
              técnicas tradicionales.
            </li>

            <li>
              Cuando se usan para problemas de optimización maximizar una función objetivo- resultan
              menos
              afectados por los máximos locales (falsas soluciones) que las técnicas tradicionales.
            </li>

            <li>
              Resulta sumamente fácil ejecutarlos en las modernas arquitecturas masivamente paralelas.
            </li>

            <li>
              Usan operadores probabilísticos, en vez de los típicos operadores determinísticos de las
              otras
              técnicas.
            </li>

            <li>
              Pueden tardar mucho en converger, o no converger en absoluto, dependiendo en cierta
              medida de los
              parámetros que se utilicen tamaño de la población, número de generaciones, etc.-.
            </li>

            <li>
              Pueden converger prematuramente debido a una serie de problemas de diversa índole.
            </li>
          </ul>
        </div>
      </article>

      <article class="title-spacing">
        <h3>2. Aplicación de los Algoritmos Genéticos</h3>
      </article>

      <article class="row">
        <div class="no-overflow column">
          <p class="Normal1"><span>La aplicación más común de los <a class="autolink" title="Algoritmos Genéticos"
                href="https://urc.cdmx.gob.mx/LAD_A1_2025-1/mod/book/view.php?id=5666">algoritmos genéticos</a> ha sido
              la
              solución de problemas de optimización, en donde han mostrado ser muy eficientes y confiables. Sin embargo,
              no
              todos los problemas pudieran ser apropiados para la técnica, y se recomienda en general tomar en cuenta
              las
              siguientes características del mismo antes de intentar usarla:</span>
          </p>

          <ul>
            <li>
              Su espacio de búsqueda (i.e., sus posibles soluciones) debe estar delimitado dentro de un
              cierto rango.
            </li>

            <li>
              Debe poderse definir una función de aptitud que nos indique qué tan buena o mala es una
              cierta respuesta.
            </li>

            <li>
              Las soluciones deben codificarse de una forma que resulte relativamente fácil de
              implementar en la computadora.
            </li>

          </ul>

          <p class="Normal1"><span>El primer punto es muy importante, y lo más recomendable es intentar resolver
              problemas que
              tengan espacios de búsqueda discretos aunque éstos sean muy grandes. Sin embargo, también podrá intentarse
              usar la
              técnica con espacios de búsqueda continuos, pero preferentemente cuando exista un rango de soluciones
              relativamente pequeño.</span>
          </p>

          <p class="Normal1"><span>La función de aptitud no es más que la función objetivo de nuestro problema de
              optimización.
              El algoritmo genético únicamente maximiza, pero la minimización puede realizarse fácilmente utilizando el
              recíproco de la función maximizante (debe cuidarse, por supuesto, que el recíproco de la función no genere
              una
              división por cero). Una característica que debe tener esta función es que tiene ser capaz de "castigar" a
              las
              malas soluciones, y de "premiar" a las buenas, de forma que sean estas últimas las que se propaguen con
              mayor
              rapidez.</span>
          </p>

          <p class="Normal1"><span>La codificación más común de las soluciones es a través de cadenas binarias, aunque
              se han
              utilizado también números reales y letras. El primero de estos esquemas ha gozado de mucha popularidad
              debido a
              que es el que propuso originalmente Holland, y además porque resulta muy sencillo de implementar
            </span>
          </p>

          <p>Como información para completar lo explicado en la secuencia sobre algoritmo genético, el desarrollo de
            software
            basados en A.G es importante para terminar de comprender la importancia de este con respecto a las búsquedas
            y temas
            anteriores, dirígete a la siguiente presentación en slideshare.
          </p>

          <p>Nombre: Desarrollo de software con algorítmicos genéticos</p>
          <p>Link: <a href="https://es.slideshare.net/uni_fcys_sistemas/desarollo-de-sofware-con-algoritmos-genticos"
              target="_blank">https://es.slideshare.net/uni_fcys_sistemas/desarollo-de-sofware-con-algoritmos-genticos</a>
          </p>
        </div>
      </article>



      <article class="title-spacing">
        <h3>3. El Algoritmo Genético Simple</h3>
      </article>

      <article class="row">
        <div class="no-overflow column">
          <p class="Normal1">El Algoritmo Genético Simple, también denominado Canónico, se necesita una codificación o
            representación del problema, que resulte adecuada al mismo. Además se requiere una función de ajuste o´
            adaptación
            al problema, la cual asigna un número real a cada posible solución codificada. Durante la ejecución del
            algoritmo de
            más abajo, los padres deben ser seleccionados para la reproducción, a continuación dichos padres
            seleccionados se
            cruzaran generando dos hijos, sobre cada uno de los cuales actuará un operador de mutación.
          </p>

          <p class="Normal1">El resultado de la combinación de las anteriores funciones será un conjunto de individuos
            (posibles
            soluciones al problema), los cuales en la evolución del Algoritmo Genético formaran parte de la siguiente
            población.
          </p>

          <div>
            <pre class="theme-base16-ashes-min  text-sm relative overflow-hidden max-w-full tab-size h-full"><span class="hljs mb-0 p-4 block min-h-full overflow-auto"><code class="no-code"><span class="hljs-variable constant_">BEGIN</span> <span class="hljs-comment">/* Algoritmo Genético Simple */</span>
  <span class="hljs-title class_">Generar</span> una población inicial.
  <span class="hljs-title class_">Computar</span> la función de evaluación de cada individuo.

  <span class="hljs-variable constant_">WHILE</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-title class_">Terminado</span> <span class="hljs-variable constant_">DO</span>

  <span class="hljs-variable constant_">BEGIN</span> <span class="hljs-comment">/* Producir nueva generación */</span>
    <span class="hljs-variable constant_">FOR</span> <span class="hljs-title class_">Tama</span>ño˜ población/<span class="hljs-number">2</span> <span class="hljs-variable constant_">DO</span>

    <span class="hljs-variable constant_">BEGIN</span> <span class="hljs-comment">/*Ciclo Reproductivo */</span>

      <span class="hljs-title class_">Seleccionar</span> dos individuos de la anterior generación,
      para el <span class="hljs-title function_">cruce</span> (probabilidad de selección proporcional
      a la función de evaluación del individuo).

      <span class="hljs-title class_">Cruzar</span> con cierta probabilidad los dos
      individuos obteniendo dos descendientes.

      <span class="hljs-title class_">Mutar</span> los dos descendientes con cierta probabilidad.

      <span class="hljs-title class_">Computar</span> la función de evaluación de los dos
      descendientes mutados.

      <span class="hljs-title class_">Insertar</span> los dos descendientes mutados en la nueva generación.

      <span class="hljs-variable constant_">END</span>
      <span class="hljs-variable constant_">IF</span> la población ha convergido <span class="hljs-variable constant_">THEN</span> <span class="hljs-title class_">Terminado</span>:= <span class="hljs-variable constant_">TRUE</span>
  <span class="hljs-variable constant_">END</span>
<span class="hljs-variable constant_">END</span></code></span></pre>
          </div>


          <hr>

          <div>
            <pre
              class="theme-base16-ashes shadow-3xl text-sm relative overflow-hidden max-w-full tab-size h-full"><span class="hljs mb-0 p-4 block min-h-full overflow-auto"><code class="no-code"><span class="hljs-variable constant_">INICIO</span>
    <span class="hljs-comment">// Generar población inicial</span>
    <span class="hljs-title class_">Generar</span> una población inicial de individuos.
                  
    <span class="hljs-comment">// Evaluar población inicial</span>
    <span class="hljs-title class_">Evaluar</span> la función de <span class="hljs-title function_">aptitud</span> (fitness) de cada individuo.
                  
    <span class="hljs-variable constant_">MIENTRAS</span> <span class="hljs-variable constant_">NO</span> se cumpla la condición de parada <span class="hljs-attr">HACER</span>:
                  
        <span class="hljs-comment">// Iniciar nueva generación</span>
        <span class="hljs-variable constant_">PARA</span> i = <span class="hljs-number">1</span> <span class="hljs-title function_">HASTA</span> (<span class="hljs-title class_">Tama</span>ño de la población / <span class="hljs-number">2</span>) <span class="hljs-attr">HACER</span>:
                  
            <span class="hljs-comment">// Selección</span>
            <span class="hljs-title class_">Seleccionar</span> dos individuos de la población actual.
            (<span class="hljs-title class_">La</span> probabilidad de selección es proporcional a su aptitud).
                  
            <span class="hljs-comment">// Cruce</span>
            <span class="hljs-title class_">Con</span> cierta probabilidad, cruzar los dos individuos seleccionados,
            produciendo dos descendientes.
                  
            <span class="hljs-comment">// Mutación</span>
            <span class="hljs-title class_">Con</span> cierta probabilidad, mutar cada descendiente.
                  
            <span class="hljs-comment">// Evaluar descendientes</span>
            <span class="hljs-title class_">Evaluar</span> la aptitud de los dos descendientes.
                  
            <span class="hljs-comment">// Insertar en nueva generación</span>
            <span class="hljs-title class_">Insertar</span> los descendientes en la nueva población.
                  
        <span class="hljs-variable constant_">FIN</span> <span class="hljs-variable constant_">PARA</span>
                  
        <span class="hljs-comment">// Comprobar convergencia</span>
        <span class="hljs-variable constant_">SI</span> la población ha convergido <span class="hljs-variable constant_">ENTONCES</span>
            <span class="hljs-title class_">Terminar</span> := <span class="hljs-variable constant_">VERDADERO</span>
                  
    <span class="hljs-variable constant_">FIN</span> <span class="hljs-variable constant_">MIENTRAS</span>
                  
<span class="hljs-variable constant_">FIN</span></code></span><small class="bg-black/30 absolute top-0 right-0 uppercase font-bold text-xs rounded-bl-md px-2 py-1"></pre>
          </div>

        </div>
      </article>

      <article class="row">
        <div class="column">
          <div class="panel panel-info">
            <div class="panel-body">
              <div class="tab-content">
                <h3>4. Referencias</h3>
                <div role="tabpanel" class="tab-pane active">
                  <ul>
                    <li>Benítez, A. (2007). Fundamentos de Inteligencia Artificial libro tercero. España: Escolar y
                      mayo.</li>
                    <li>Escolano, F. (2003). Inteligencia Artificial (Modelos, Técnicas y Áreas de Aplicación) México:
                      Thomson.</li>
                    <li>Marín, R. (2008). Inteligencia Artificial y sistemas inteligentes. España: McGraw-Hill.</li>
                    <li>Nilsson, N. (2001). Inteligencia artificial (Una nueva síntesis) México: McGraw–Hill.</li>
                    <li>Ponce, P. (2011). Inteligencia Artificial con aplicaciones a la ingeniería. España: MARCOMBO.
                    </li>
                    <li>Facultad de ciencias y sistemas. (2011). Desarrollo de software con algorítmicos genéticos.
                      Sitio web: <a
                        href="https://es.slideshare.net/uni_fcys_sistemas/desarollo-de-sofware-con-algoritmos-genticos"
                        class="_blanktarget">https://es.slideshare.net/uni_fcys_sistemas/desarollo-de-sofware-con-algoritmos-genticos</a>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>


    </div>
  </section>

  <div id="pagina-6"></div>
  <section class="wrapper">
    <div class="contenido-principal">
      <article>
        <h2>Algoritmos Genéticos 3</h3>
      </article>

      <article class="title-spacing">
        <h3>1. Algoritmo Genético</h3>
      </article>

      <article class="row">
        <div class="no-overflow column">
          <p class="Normal1">Los <a class="autolink" title="Algoritmos Genéticos"
              href="https://urc.cdmx.gob.mx/LAD_A1_2025-1/mod/book/view.php?id=5666">Algoritmos Genéticos</a> (AGs) son
            métodos
            adaptativos que pueden usarse para resolver problemas de búsqueda y optimización. Están basados en el
            proceso
            genético de los organismos vivos. A lo largo de las generaciones, las poblaciones evolucionan en la
            naturaleza de
            acorde con los principios de la selección natural y la supervivencia de los más fuertes, postulados por
            Darwin. Por
            imitación de este proceso, los <a class="autolink" title="Algoritmos Genéticos"
              href="https://urc.cdmx.gob.mx/LAD_A1_2025-1/mod/book/view.php?id=5666">Algoritmos Genéticos</a> son
            capaces de ir
            creando soluciones para problemas del mundo real. La evolución de dichas soluciones hacia valores óptimos
            del
            problema depende en buena medida de una adecuada codificación de las mismas.
          </p>

          <p class="Normal1">Un algoritmo genético consiste en una función matemática o una rutina de software que toma
            como
            entradas a los ejemplares y retorna como salidas cuáles de ellos deben generar descendencia para la nueva
            generación.
          </p>

          <p class="Normal1">Versiones más complejas de <a class="autolink" title="Algoritmos Genéticos"
              href="https://urc.cdmx.gob.mx/LAD_A1_2025-1/mod/book/view.php?id=5666">algoritmos genéticos</a> generan un
            ciclo
            iterativo que directamente toma a la especie (el total de los ejemplares) y crea una nueva generación que
            reemplaza
            a la antigua una cantidad de veces determinada por su propio diseño. Una de sus características principales
            es la de
            ir perfeccionando su propia heurística en el proceso de ejecución, por lo que no requiere largos períodos de
            entrenamiento especializado por parte del ser humano, principal defecto de otros métodos para solucionar
            problemas,
            como los Sistemas Expertos.
          </p>

          <ul>
            <li>
              Operan de forma simultánea con varias soluciones, en vez de trabajar de forma secuencial como las
              técnicas tradicionales.
            </li>

            <li>
              Cuando se usan para problemas de optimización maximizar una función objetivo- resultan menos
              afectados por los máximos locales (falsas soluciones) que las técnicas tradicionales.
            </li>

            <li>
              Resulta sumamente fácil ejecutarlos en las modernas arquitecturas masivamente paralelas.
            </li>

            <li>
              Usan operadores probabilísticos, en vez de los típicos operadores determinísticos de las otras
              técnicas.
            </li>

            <li>
              Pueden tardar mucho en converger, o no converger en absoluto, dependiendo en cierta medida de los
              parámetros que se utilicen tamaño de la población, número de generaciones, etc.-.
            </li>

            <li>
              Pueden converger prematuramente debido a una serie de problemas de diversa índole.
            </li>
          </ul>
        </div>
      </article>

      <article class="title-spacing">
        <h3>2. Aplicación de los Algoritmos Genéticos</h3>
      </article>

      <article class="row">
        <div class="no-overflow column">
          <p class="Normal1"><span>La aplicación más común de los <a class="autolink" title="Algoritmos Genéticos"
                href="https://urc.cdmx.gob.mx/LAD_A1_2025-1/mod/book/view.php?id=5666">algoritmos genéticos</a> ha sido
              la
              solución de problemas de optimización, en donde han mostrado ser muy eficientes y confiables. Sin embargo,
              no
              todos los problemas pudieran ser apropiados para la técnica, y se recomienda en general tomar en cuenta
              las
              siguientes características del mismo antes de intentar usarla:</span>
            </p>

            <ul>
              <li>
                Su espacio de búsqueda (i.e., sus posibles soluciones) debe estar delimitado dentro
                de un
                cierto rango.
              </li>

              <li>
                Debe poderse definir una función de aptitud que nos indique qué tan buena o mala es
                una
                cierta respuesta.
              </li>

              <li>
                Las soluciones deben codificarse de una forma que resulte relativamente fácil de
                implementar en la computadora.
              </li>
            </ul>

          <p class="Normal1"><span>El primer punto es muy importante, y lo más recomendable es intentar resolver
              problemas que
              tengan espacios de búsqueda discretos aunque éstos sean muy grandes. Sin embargo, también podrá intentarse
              usar la
              técnica con espacios de búsqueda continuos, pero preferentemente cuando exista un rango de soluciones
              relativamente pequeño. </span>
          </p>
        
          <p class="Normal1"><span>La función de aptitud no es más que la función objetivo de nuestro problema de
              optimización.
              El algoritmo genético únicamente maximiza, pero la minimización puede realizarse fácilmente utilizando el
              recíproco de la función maximizante (debe cuidarse, por supuesto, que el recíproco de la función no genere
              una
              división por cero). Una característica que debe tener esta función es que tiene ser capaz de "castigar" a
              las
              malas soluciones, y de "premiar" a las buenas, de forma que sean estas últimas las que se propaguen con
              mayor
              rapidez.</span>
          </p>
          
          <p class="Normal1"><span>La codificación más común de las soluciones es a través de cadenas binarias, aunque
              se han
              utilizado también números reales y letras. El primero de estos esquemas ha gozado de mucha popularidad
              debido a
              que es el que propuso originalmente Holland, y además porque resulta muy sencillo de implementar.
            </span>
          </p>
          
          <p>Como información para completar lo explicado en la secuencia sobre algoritmo genético, el desarrollo de
            software
            basados en A.G es importante para terminar de comprender la importancia de este con respecto a las búsquedas
            y temas
            anteriores, dirígete a la siguiente presentación en slideshare.
          </p>

          <p>Nombre: Desarrollo de software con algorítmicos genéticos</p>

          <p>Link: <a href="https://es.slideshare.net/uni_fcys_sistemas/desarollo-de-sofware-con-algoritmos-genticos"
              target="_blank">https://es.slideshare.net/uni_fcys_sistemas/desarollo-de-sofware-con-algoritmos-genticos</a>
          </p>
        </div>
      </article>


      <article class="row">
        <div class="column">
          <div class="panel panel-info">
            <div class="panel-body">
              <div class="tab-content">
                <h3>3. Referencias</h3>
                <div role="tabpanel" class="tab-pane active">
                  <ul>
                    <li>
                        Facultad de ciencias y sistemas. (2011). Desarrollo de software con
                        algorítmicos genéticos. Sitio web: <a
                          href="https://es.slideshare.net/uni_fcys_sistemas/desarollo-de-sofware-con-algoritmos-genticos"
                          class="_blanktarget">https://es.slideshare.net/uni_fcys_sistemas/desarollo-de-sofware-con-algoritmos-genticos</a>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>
    </div>
  </section>

  <footer>
    <div class="container">
      <div class="row">
        <div class="column">
          <div class="logotipos">
            <img src="../../assets/images/logos_encabezado.svg">
          </div>
        </div>
      </div>
    </div>
  </footer>

  <!-- <script defer src="https://use.fontawesome.com/releases/v5.0.4/js/all.js"></script> -->
  <script src="../../assets/fontawesome-all.min.js.descarga"></script>
  <script src="../../assets/plugins.js.descarga"></script>
  <script src="../../assets/main.js.descarga"></script>


  <style>
    .wrapper {

      code:not(.no-code) {
        color: #000;
        background-color: rgb(201, 193, 193);
      }

      article.title-spacing {
        margin-top: 16px;
        margin-bottom: 0;

        h3 {
          margin-bottom: 8px;
        }
      }
    }
  </style>
</body>

</html>
